---
layout: post
title:  "패캠 JAVA 4일차"
date:   2016-12-01 19:30:01 -0500
categories: 교육
fb_title: java_day4
---

자바 웹프로그래밍 2기 강의 4일차 내용을 정리한 포스팅입니다.

# 배움 관련 이야기

- 내 색깔로 내 속도로 ***꾸준히*** 하는 태도가 중요하다. (공감)
- 내가 맞다고 생각하면 휘둘리지 말고 생각한대 까지는 가보는 것이 중요하다.


- 이너게임 (배우며 즐겁게 일하는 법)
- 몰입의 즐거움

# REST Update 시 필요한 필드만 업데이트 해주는 습관을 가지자

- 조회 쿼리가 한번 더 들어간다고 나쁜것은 아니다.
  - 바로 Repository.save(user) 해주면 모든 필드가 업데이트 된다.
  - 이때 문제점은 굳이 업데이트 하지 않아야 하는 필드까지 클라이언트 까지 전달을 해줘야하여 예외가 일어날 확률이 높아진다.

``` java

@PostMapping("/{id}/update")
public String update(@PathVariable Long id, User user) {

    // userRepository.save(user); : 전체 필드를 업데이트 치기 때문에 좋은 습관이 아니다
                                 // 실제 개발에서는 사실 일부만 업데이트 되는 경우가 대다수다.
                                 // 불필요하게 쓰지 않는 필드까지 클라이언트까지 전달해야 한다.

    // 수정을 할때에는 조회를 해서 필요한 필드만 업데이트 해줘야 좀 더 안전하게 관리할 수 있다.
    // 따라서 반드시 이렇게 해주는게 좋다.
    User dbUser = userRepository.findOne(id);
    dbUser.update(user); // 객체지향 : 객체에게 해야할 일을 위임해줘야 가독성이 훨씬 좋아진다.
    userRepository.save(dbUser);

    return "redirect:/users";
}

```


# 객체지향

- 객체지향에서의 객체는 상태값을 가지면서 **행위** 까지도 가진다.
  - State + Action
  - 가독성이 높아지며 후에 중복 코드도 줄일 수 있다.


- 객체지향에서는 객체에게 메시지를 보낸다.

## 메서드를 쪼개는 것을 두려워 하지 마라

- 메소드는 하나의 역할(Role) 만하도록 구현한다. 라인 하나짜리 메소드여도 괜찮다.

``` java

// controller
User dbUser = userRepository.findOne(id);
dbUser.update(user); // 객체지향 : 객체에게 해야할 일을 위임해줘야 가독성이 훨씬 좋아진다.
userRepository.save(dbUser);


// User domain
public boolean matchPassword (String password) {
    return this.password.equals(password);
}

public void update (User user) {
    if (!this.matchPassword(user.password)) {
        throw new IllegalArgumentException("비밀번호가 일치하지 않는다.");
    }
    this.name = user.name;
    this.email = user.email;
}

```


# 서버딴에서도 로직 수행전에 방어 코드를 넣는 습관을 넣자

- 예외로직은 if 문으로만 else는 되도록 쓰지 말자
  - 즉, 방어로직 ... 비지니스로직 순으로 작성하는 습관들이자

``` java

@PutMapping("/{id}/update")
public String update(@PathVariable Long id, User user, HttpSession session) {
   // 방어 코드
   Object sessionUser = session.getAttribute("loginUser");

   if (sessionUser == null) {
       return "redirect:/users/login";
   }
   User loginUser = (User) sessionUser;

   if (!loginUser.matchId(id)) {
       throw new IllegalStateException("다른 사람의 정보를 수정 할 수 없습니다.");
   }

   // 비지니스 로직
   User dbUser = userRepository.findOne(id);
   dbUser.update(user);
   userRepository.save(dbUser);

   return "redirect:/users";
}

```

# Http는 무상태(state-less) 프로토콜이다.

- Http 프로토콜은 연결을 계속 맺고있지 않는다.
  - request, response

- 상태를 유지하지 못한다 -> Session, Cookie : 상태를 유지하게 해주는 기능

# Cookie, Session (1)

- 매요청시 header(?)에 실려서 상태를 전송해줘서 클라이언트가 상태를 알 수 있게 해준다.


## mustache session 사용 default = false
```
spring.mustache.expose-session-attributes=false
```
